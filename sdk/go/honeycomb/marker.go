// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package honeycomb

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # Resource: Marker
//
// Creates a marker. For more information about markers, check out [Annotate the timeline with Markers](https://docs.honeycomb.io/working-with-your-data/customizing-your-query/markers/).
//
// > **Note** Destroying or replacing this resource will not delete the previously created marker. This is intentional to preserve the markers. At this time, it is not possible to remove markers using this provider.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-honeycomb/sdk/go/honeycomb"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		cfg := config.New(ctx, "")
// 		dataset := cfg.Require("dataset")
// 		appVersion := cfg.Require("appVersion")
// 		_, err := honeycomb.NewMarker(ctx, "marker", &honeycomb.MarkerArgs{
// 			Message: pulumi.String(fmt.Sprintf("deploy %v", appVersion)),
// 			Type:    pulumi.String("deploy"),
// 			Url:     pulumi.String("http://www.example.com/"),
// 			Dataset: pulumi.String(dataset),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type Marker struct {
	pulumi.CustomResourceState

	// The dataset this marker is placed on.
	Dataset pulumi.StringOutput `pulumi:"dataset"`
	// The message on the marker.
	Message pulumi.StringPtrOutput `pulumi:"message"`
	// The type of the marker, Honeycomb.io can display markers in different colors depending on their type.
	Type pulumi.StringPtrOutput `pulumi:"type"`
	// A target for the Marker. If you click on the Marker text, it will take you to this URL.
	Url pulumi.StringPtrOutput `pulumi:"url"`
}

// NewMarker registers a new resource with the given unique name, arguments, and options.
func NewMarker(ctx *pulumi.Context,
	name string, args *MarkerArgs, opts ...pulumi.ResourceOption) (*Marker, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Dataset == nil {
		return nil, errors.New("invalid value for required argument 'Dataset'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource Marker
	err := ctx.RegisterResource("honeycomb:index/marker:Marker", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMarker gets an existing Marker resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMarker(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MarkerState, opts ...pulumi.ResourceOption) (*Marker, error) {
	var resource Marker
	err := ctx.ReadResource("honeycomb:index/marker:Marker", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Marker resources.
type markerState struct {
	// The dataset this marker is placed on.
	Dataset *string `pulumi:"dataset"`
	// The message on the marker.
	Message *string `pulumi:"message"`
	// The type of the marker, Honeycomb.io can display markers in different colors depending on their type.
	Type *string `pulumi:"type"`
	// A target for the Marker. If you click on the Marker text, it will take you to this URL.
	Url *string `pulumi:"url"`
}

type MarkerState struct {
	// The dataset this marker is placed on.
	Dataset pulumi.StringPtrInput
	// The message on the marker.
	Message pulumi.StringPtrInput
	// The type of the marker, Honeycomb.io can display markers in different colors depending on their type.
	Type pulumi.StringPtrInput
	// A target for the Marker. If you click on the Marker text, it will take you to this URL.
	Url pulumi.StringPtrInput
}

func (MarkerState) ElementType() reflect.Type {
	return reflect.TypeOf((*markerState)(nil)).Elem()
}

type markerArgs struct {
	// The dataset this marker is placed on.
	Dataset string `pulumi:"dataset"`
	// The message on the marker.
	Message *string `pulumi:"message"`
	// The type of the marker, Honeycomb.io can display markers in different colors depending on their type.
	Type *string `pulumi:"type"`
	// A target for the Marker. If you click on the Marker text, it will take you to this URL.
	Url *string `pulumi:"url"`
}

// The set of arguments for constructing a Marker resource.
type MarkerArgs struct {
	// The dataset this marker is placed on.
	Dataset pulumi.StringInput
	// The message on the marker.
	Message pulumi.StringPtrInput
	// The type of the marker, Honeycomb.io can display markers in different colors depending on their type.
	Type pulumi.StringPtrInput
	// A target for the Marker. If you click on the Marker text, it will take you to this URL.
	Url pulumi.StringPtrInput
}

func (MarkerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*markerArgs)(nil)).Elem()
}

type MarkerInput interface {
	pulumi.Input

	ToMarkerOutput() MarkerOutput
	ToMarkerOutputWithContext(ctx context.Context) MarkerOutput
}

func (*Marker) ElementType() reflect.Type {
	return reflect.TypeOf((**Marker)(nil)).Elem()
}

func (i *Marker) ToMarkerOutput() MarkerOutput {
	return i.ToMarkerOutputWithContext(context.Background())
}

func (i *Marker) ToMarkerOutputWithContext(ctx context.Context) MarkerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MarkerOutput)
}

// MarkerArrayInput is an input type that accepts MarkerArray and MarkerArrayOutput values.
// You can construct a concrete instance of `MarkerArrayInput` via:
//
//          MarkerArray{ MarkerArgs{...} }
type MarkerArrayInput interface {
	pulumi.Input

	ToMarkerArrayOutput() MarkerArrayOutput
	ToMarkerArrayOutputWithContext(context.Context) MarkerArrayOutput
}

type MarkerArray []MarkerInput

func (MarkerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Marker)(nil)).Elem()
}

func (i MarkerArray) ToMarkerArrayOutput() MarkerArrayOutput {
	return i.ToMarkerArrayOutputWithContext(context.Background())
}

func (i MarkerArray) ToMarkerArrayOutputWithContext(ctx context.Context) MarkerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MarkerArrayOutput)
}

// MarkerMapInput is an input type that accepts MarkerMap and MarkerMapOutput values.
// You can construct a concrete instance of `MarkerMapInput` via:
//
//          MarkerMap{ "key": MarkerArgs{...} }
type MarkerMapInput interface {
	pulumi.Input

	ToMarkerMapOutput() MarkerMapOutput
	ToMarkerMapOutputWithContext(context.Context) MarkerMapOutput
}

type MarkerMap map[string]MarkerInput

func (MarkerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Marker)(nil)).Elem()
}

func (i MarkerMap) ToMarkerMapOutput() MarkerMapOutput {
	return i.ToMarkerMapOutputWithContext(context.Background())
}

func (i MarkerMap) ToMarkerMapOutputWithContext(ctx context.Context) MarkerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MarkerMapOutput)
}

type MarkerOutput struct{ *pulumi.OutputState }

func (MarkerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Marker)(nil)).Elem()
}

func (o MarkerOutput) ToMarkerOutput() MarkerOutput {
	return o
}

func (o MarkerOutput) ToMarkerOutputWithContext(ctx context.Context) MarkerOutput {
	return o
}

// The dataset this marker is placed on.
func (o MarkerOutput) Dataset() pulumi.StringOutput {
	return o.ApplyT(func(v *Marker) pulumi.StringOutput { return v.Dataset }).(pulumi.StringOutput)
}

// The message on the marker.
func (o MarkerOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Marker) pulumi.StringPtrOutput { return v.Message }).(pulumi.StringPtrOutput)
}

// The type of the marker, Honeycomb.io can display markers in different colors depending on their type.
func (o MarkerOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Marker) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

// A target for the Marker. If you click on the Marker text, it will take you to this URL.
func (o MarkerOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Marker) pulumi.StringPtrOutput { return v.Url }).(pulumi.StringPtrOutput)
}

type MarkerArrayOutput struct{ *pulumi.OutputState }

func (MarkerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Marker)(nil)).Elem()
}

func (o MarkerArrayOutput) ToMarkerArrayOutput() MarkerArrayOutput {
	return o
}

func (o MarkerArrayOutput) ToMarkerArrayOutputWithContext(ctx context.Context) MarkerArrayOutput {
	return o
}

func (o MarkerArrayOutput) Index(i pulumi.IntInput) MarkerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Marker {
		return vs[0].([]*Marker)[vs[1].(int)]
	}).(MarkerOutput)
}

type MarkerMapOutput struct{ *pulumi.OutputState }

func (MarkerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Marker)(nil)).Elem()
}

func (o MarkerMapOutput) ToMarkerMapOutput() MarkerMapOutput {
	return o
}

func (o MarkerMapOutput) ToMarkerMapOutputWithContext(ctx context.Context) MarkerMapOutput {
	return o
}

func (o MarkerMapOutput) MapIndex(k pulumi.StringInput) MarkerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Marker {
		return vs[0].(map[string]*Marker)[vs[1].(string)]
	}).(MarkerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MarkerInput)(nil)).Elem(), &Marker{})
	pulumi.RegisterInputType(reflect.TypeOf((*MarkerArrayInput)(nil)).Elem(), MarkerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MarkerMapInput)(nil)).Elem(), MarkerMap{})
	pulumi.RegisterOutputType(MarkerOutput{})
	pulumi.RegisterOutputType(MarkerArrayOutput{})
	pulumi.RegisterOutputType(MarkerMapOutput{})
}
